// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: device_tokens.sql

package generated

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countDeviceTokens = `-- name: CountDeviceTokens :one
SELECT COUNT(*) AS total_device_tokens
FROM device_tokens
WHERE
    active IS TRUE
    AND (
        $1::boolean IS NULL 
        OR active = $1
    )
    AND (
        $2::text IS NULL 
        OR platform = $2
    )
`

type CountDeviceTokensParams struct {
	IsActive pgtype.Bool `json:"is_active"`
	Platform pgtype.Text `json:"platform"`
}

func (q *Queries) CountDeviceTokens(ctx context.Context, arg CountDeviceTokensParams) (int64, error) {
	row := q.db.QueryRow(ctx, countDeviceTokens, arg.IsActive, arg.Platform)
	var total_device_tokens int64
	err := row.Scan(&total_device_tokens)
	return total_device_tokens, err
}

const createDeviceToken = `-- name: CreateDeviceToken :one
INSERT INTO device_tokens (user_id, device_token, platform)
VALUES ($1, $2, $3)
RETURNING id
`

type CreateDeviceTokenParams struct {
	UserID      int64  `json:"user_id"`
	DeviceToken string `json:"device_token"`
	Platform    string `json:"platform"`
}

func (q *Queries) CreateDeviceToken(ctx context.Context, arg CreateDeviceTokenParams) (int64, error) {
	row := q.db.QueryRow(ctx, createDeviceToken, arg.UserID, arg.DeviceToken, arg.Platform)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getDeviceTokenByID = `-- name: GetDeviceTokenByID :one
SELECT dt.id, dt.user_id, dt.device_token, dt.platform, dt.active, dt.created_at,
       u.email AS user_email,
       u.full_name AS user_full_name,
       u.role AS user_role
FROM device_tokens dt
JOIN users u ON dt.user_id = u.id
WHERE dt.id = $1
`

type GetDeviceTokenByIDRow struct {
	ID           int64     `json:"id"`
	UserID       int64     `json:"user_id"`
	DeviceToken  string    `json:"device_token"`
	Platform     string    `json:"platform"`
	Active       bool      `json:"active"`
	CreatedAt    time.Time `json:"created_at"`
	UserEmail    string    `json:"user_email"`
	UserFullName string    `json:"user_full_name"`
	UserRole     []string  `json:"user_role"`
}

func (q *Queries) GetDeviceTokenByID(ctx context.Context, id int64) (GetDeviceTokenByIDRow, error) {
	row := q.db.QueryRow(ctx, getDeviceTokenByID, id)
	var i GetDeviceTokenByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DeviceToken,
		&i.Platform,
		&i.Active,
		&i.CreatedAt,
		&i.UserEmail,
		&i.UserFullName,
		&i.UserRole,
	)
	return i, err
}

const getDeviceTokenByUserID = `-- name: GetDeviceTokenByUserID :many
SELECT dt.id, dt.user_id, dt.device_token, dt.platform, dt.active, dt.created_at,
       u.email AS user_email,
       u.full_name AS user_full_name,
       u.role AS user_role
FROM device_tokens dt
JOIN users u ON dt.user_id = u.id
WHERE dt.active IS TRUE AND dt.user_id = $1
`

type GetDeviceTokenByUserIDRow struct {
	ID           int64     `json:"id"`
	UserID       int64     `json:"user_id"`
	DeviceToken  string    `json:"device_token"`
	Platform     string    `json:"platform"`
	Active       bool      `json:"active"`
	CreatedAt    time.Time `json:"created_at"`
	UserEmail    string    `json:"user_email"`
	UserFullName string    `json:"user_full_name"`
	UserRole     []string  `json:"user_role"`
}

func (q *Queries) GetDeviceTokenByUserID(ctx context.Context, userID int64) ([]GetDeviceTokenByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getDeviceTokenByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDeviceTokenByUserIDRow{}
	for rows.Next() {
		var i GetDeviceTokenByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DeviceToken,
			&i.Platform,
			&i.Active,
			&i.CreatedAt,
			&i.UserEmail,
			&i.UserFullName,
			&i.UserRole,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeviceTokens = `-- name: ListDeviceTokens :many
SELECT 
    dt.id, dt.user_id, dt.device_token, dt.platform, dt.active, dt.created_at,
    u.email AS user_email,
    u.full_name AS user_full_name,
    u.role AS user_role
FROM device_tokens dt
JOIN users u ON dt.user_id = u.id
WHERE
    dt.active IS TRUE
    AND (
        $1::boolean IS NULL 
        OR dt.active = $1
    )
    AND (
        $2::text IS NULL 
        OR dt.platform = $2
    )
ORDER BY dt.created_at DESC
LIMIT $4 OFFSET $3
`

type ListDeviceTokensParams struct {
	IsActive pgtype.Bool `json:"is_active"`
	Platform pgtype.Text `json:"platform"`
	Offset   int32       `json:"offset"`
	Limit    int32       `json:"limit"`
}

type ListDeviceTokensRow struct {
	ID           int64     `json:"id"`
	UserID       int64     `json:"user_id"`
	DeviceToken  string    `json:"device_token"`
	Platform     string    `json:"platform"`
	Active       bool      `json:"active"`
	CreatedAt    time.Time `json:"created_at"`
	UserEmail    string    `json:"user_email"`
	UserFullName string    `json:"user_full_name"`
	UserRole     []string  `json:"user_role"`
}

func (q *Queries) ListDeviceTokens(ctx context.Context, arg ListDeviceTokensParams) ([]ListDeviceTokensRow, error) {
	rows, err := q.db.Query(ctx, listDeviceTokens,
		arg.IsActive,
		arg.Platform,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDeviceTokensRow{}
	for rows.Next() {
		var i ListDeviceTokensRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DeviceToken,
			&i.Platform,
			&i.Active,
			&i.CreatedAt,
			&i.UserEmail,
			&i.UserFullName,
			&i.UserRole,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDeviceToken = `-- name: UpdateDeviceToken :exec
UPDATE device_tokens
SET active = $1
WHERE user_id = $2 AND active IS TRUE
`

type UpdateDeviceTokenParams struct {
	Active bool  `json:"active"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) UpdateDeviceToken(ctx context.Context, arg UpdateDeviceTokenParams) error {
	_, err := q.db.Exec(ctx, updateDeviceToken, arg.Active, arg.UserID)
	return err
}

const userHasActiveDeviceToken = `-- name: UserHasActiveDeviceToken :one
SELECT EXISTS (SELECT 1 FROM device_tokens WHERE user_id = $1 AND active IS TRUE)
`

func (q *Queries) UserHasActiveDeviceToken(ctx context.Context, userID int64) (bool, error) {
	row := q.db.QueryRow(ctx, userHasActiveDeviceToken, userID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
