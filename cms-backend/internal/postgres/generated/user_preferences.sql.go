// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: user_preferences.sql

package generated

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countUserPreferences = `-- name: CountUserPreferences :one
SELECT COUNT(*) AS total_user_preferences
FROM user_preferences
`

func (q *Queries) CountUserPreferences(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countUserPreferences)
	var total_user_preferences int64
	err := row.Scan(&total_user_preferences)
	return total_user_preferences, err
}

const createUserPreferences = `-- name: CreateUserPreferences :one
INSERT INTO user_preferences (user_id, notify_policy, notify_news, notify_events, notify_training)
VALUES ($1, $2, $3, $4, $5)
RETURNING user_id, notify_news, notify_events, notify_training, notify_policy, updated_at, created_at
`

type CreateUserPreferencesParams struct {
	UserID         int64 `json:"user_id"`
	NotifyPolicy   bool  `json:"notify_policy"`
	NotifyNews     bool  `json:"notify_news"`
	NotifyEvents   bool  `json:"notify_events"`
	NotifyTraining bool  `json:"notify_training"`
}

func (q *Queries) CreateUserPreferences(ctx context.Context, arg CreateUserPreferencesParams) (UserPreference, error) {
	row := q.db.QueryRow(ctx, createUserPreferences,
		arg.UserID,
		arg.NotifyPolicy,
		arg.NotifyNews,
		arg.NotifyEvents,
		arg.NotifyTraining,
	)
	var i UserPreference
	err := row.Scan(
		&i.UserID,
		&i.NotifyNews,
		&i.NotifyEvents,
		&i.NotifyTraining,
		&i.NotifyPolicy,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUserPreferences = `-- name: GetUserPreferences :one
SELECT up.user_id, up.notify_news, up.notify_events, up.notify_training, up.notify_policy, up.updated_at, up.created_at,
       u.email AS user_email,
       u.full_name AS user_full_name,
       u.role AS user_role
FROM user_preferences up
JOIN users u ON up.user_id = u.id
WHERE up.user_id = $1
`

type GetUserPreferencesRow struct {
	UserID         int64     `json:"user_id"`
	NotifyNews     bool      `json:"notify_news"`
	NotifyEvents   bool      `json:"notify_events"`
	NotifyTraining bool      `json:"notify_training"`
	NotifyPolicy   bool      `json:"notify_policy"`
	UpdatedAt      time.Time `json:"updated_at"`
	CreatedAt      time.Time `json:"created_at"`
	UserEmail      string    `json:"user_email"`
	UserFullName   string    `json:"user_full_name"`
	UserRole       []string  `json:"user_role"`
}

func (q *Queries) GetUserPreferences(ctx context.Context, userID int64) (GetUserPreferencesRow, error) {
	row := q.db.QueryRow(ctx, getUserPreferences, userID)
	var i GetUserPreferencesRow
	err := row.Scan(
		&i.UserID,
		&i.NotifyNews,
		&i.NotifyEvents,
		&i.NotifyTraining,
		&i.NotifyPolicy,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.UserEmail,
		&i.UserFullName,
		&i.UserRole,
	)
	return i, err
}

const listUserPreferences = `-- name: ListUserPreferences :many
SELECT 
    up.user_id, up.notify_news, up.notify_events, up.notify_training, up.notify_policy, up.updated_at, up.created_at,
    u.email AS user_email,
    u.full_name AS user_full_name,
    u.role AS user_role
FROM user_preferences up
JOIN users u ON up.user_id = u.id
ORDER BY up.created_at DESC
LIMIT $2 OFFSET $1
`

type ListUserPreferencesParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

type ListUserPreferencesRow struct {
	UserID         int64     `json:"user_id"`
	NotifyNews     bool      `json:"notify_news"`
	NotifyEvents   bool      `json:"notify_events"`
	NotifyTraining bool      `json:"notify_training"`
	NotifyPolicy   bool      `json:"notify_policy"`
	UpdatedAt      time.Time `json:"updated_at"`
	CreatedAt      time.Time `json:"created_at"`
	UserEmail      string    `json:"user_email"`
	UserFullName   string    `json:"user_full_name"`
	UserRole       []string  `json:"user_role"`
}

func (q *Queries) ListUserPreferences(ctx context.Context, arg ListUserPreferencesParams) ([]ListUserPreferencesRow, error) {
	rows, err := q.db.Query(ctx, listUserPreferences, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserPreferencesRow{}
	for rows.Next() {
		var i ListUserPreferencesRow
		if err := rows.Scan(
			&i.UserID,
			&i.NotifyNews,
			&i.NotifyEvents,
			&i.NotifyTraining,
			&i.NotifyPolicy,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.UserEmail,
			&i.UserFullName,
			&i.UserRole,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserPreferences = `-- name: UpdateUserPreferences :one
UPDATE user_preferences
SET notify_news = COALESCE($2, notify_news),
    notify_events = COALESCE($3, notify_events),
    notify_training = COALESCE($4, notify_training),
    notify_policy = COALESCE($5, notify_policy)
WHERE user_id = $1
RETURNING user_id, notify_news, notify_events, notify_training, notify_policy, updated_at, created_at
`

type UpdateUserPreferencesParams struct {
	UserID         int64       `json:"user_id"`
	NotifyNews     pgtype.Bool `json:"notify_news"`
	NotifyEvents   pgtype.Bool `json:"notify_events"`
	NotifyTraining pgtype.Bool `json:"notify_training"`
	NotifyPolicy   pgtype.Bool `json:"notify_policy"`
}

func (q *Queries) UpdateUserPreferences(ctx context.Context, arg UpdateUserPreferencesParams) (UserPreference, error) {
	row := q.db.QueryRow(ctx, updateUserPreferences,
		arg.UserID,
		arg.NotifyNews,
		arg.NotifyEvents,
		arg.NotifyTraining,
		arg.NotifyPolicy,
	)
	var i UserPreference
	err := row.Scan(
		&i.UserID,
		&i.NotifyNews,
		&i.NotifyEvents,
		&i.NotifyTraining,
		&i.NotifyPolicy,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
