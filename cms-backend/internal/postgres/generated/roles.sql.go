// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: roles.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getRole = `-- name: GetRole :one
SELECT id, name, description, is_system_role, is_active, created_by, updated_by, created_at, updated_at FROM rbac_roles 
WHERE id = $1
`

func (q *Queries) GetRole(ctx context.Context, id int64) (RbacRole, error) {
	row := q.db.QueryRow(ctx, getRole, id)
	var i RbacRole
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IsSystemRole,
		&i.IsActive,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRoleByName = `-- name: GetRoleByName :one
SELECT id, name, description, is_system_role, is_active, created_by, updated_by, created_at, updated_at FROM rbac_roles
WHERE name = $1
`

func (q *Queries) GetRoleByName(ctx context.Context, name string) (RbacRole, error) {
	row := q.db.QueryRow(ctx, getRoleByName, name)
	var i RbacRole
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IsSystemRole,
		&i.IsActive,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserRoles = `-- name: GetUserRoles :many
SELECT r.id, r.name, r.description, r.is_system_role, r.is_active, r.created_by, r.updated_by, r.created_at, r.updated_at
FROM rbac_user_roles ur
JOIN rbac_roles r ON ur.role_id = r.id
WHERE ur.user_id = $1
`

func (q *Queries) GetUserRoles(ctx context.Context, userID int64) ([]RbacRole, error) {
	rows, err := q.db.Query(ctx, getUserRoles, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RbacRole{}
	for rows.Next() {
		var i RbacRole
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.IsSystemRole,
			&i.IsActive,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const grantRole = `-- name: GrantRole :exec
INSERT INTO rbac_user_roles (user_id, role_id, assigned_by, expires_at)
VALUES ($1, $2, $3, $4)
`

type GrantRoleParams struct {
	UserID     int64              `json:"user_id"`
	RoleID     int64              `json:"role_id"`
	AssignedBy int64              `json:"assigned_by"`
	ExpiresAt  pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) GrantRole(ctx context.Context, arg GrantRoleParams) error {
	_, err := q.db.Exec(ctx, grantRole,
		arg.UserID,
		arg.RoleID,
		arg.AssignedBy,
		arg.ExpiresAt,
	)
	return err
}

const logAuditLog = `-- name: LogAuditLog :exec
INSERT INTO rbac_audit_log (action, entity_type, entity_id, old_values, new_values, performed_by)
VALUES ($1, $2, $3, $4, $5, $6)
`

type LogAuditLogParams struct {
	Action      string `json:"action"`
	EntityType  string `json:"entity_type"`
	EntityID    int64  `json:"entity_id"`
	OldValues   []byte `json:"old_values"`
	NewValues   []byte `json:"new_values"`
	PerformedBy int64  `json:"performed_by"`
}

func (q *Queries) LogAuditLog(ctx context.Context, arg LogAuditLogParams) error {
	_, err := q.db.Exec(ctx, logAuditLog,
		arg.Action,
		arg.EntityType,
		arg.EntityID,
		arg.OldValues,
		arg.NewValues,
		arg.PerformedBy,
	)
	return err
}

const removeUserRoles = `-- name: RemoveUserRoles :exec
DELETE FROM rbac_user_roles
WHERE user_id = $1
`

func (q *Queries) RemoveUserRoles(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, removeUserRoles, userID)
	return err
}
