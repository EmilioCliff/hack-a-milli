// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: payments.sql

package generated

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPayments = `-- name: CountPayments :one
SELECT COUNT(*) AS total_payments
FROM payments
WHERE
    (
        $1::bigint IS NULL 
        OR order_id = $1
    )
    AND (
        $2::bigint IS NULL 
        OR user_id = $2
    )
    AND (
        COALESCE($3, '') = '' 
        OR LOWER(payment_method) LIKE $3
    )
    AND (
        $4::boolean IS NULL 
        OR status = $4
    )
    AND (
        $5 IS NULL 
        OR created_at BETWEEN $5 AND $6
    )
`

type CountPaymentsParams struct {
	OrderID       pgtype.Int8        `json:"order_id"`
	UserID        pgtype.Int8        `json:"user_id"`
	PaymentMethod interface{}        `json:"payment_method"`
	Status        pgtype.Bool        `json:"status"`
	StartDate     interface{}        `json:"start_date"`
	EndDate       pgtype.Timestamptz `json:"end_date"`
}

func (q *Queries) CountPayments(ctx context.Context, arg CountPaymentsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPayments,
		arg.OrderID,
		arg.UserID,
		arg.PaymentMethod,
		arg.Status,
		arg.StartDate,
		arg.EndDate,
	)
	var total_payments int64
	err := row.Scan(&total_payments)
	return total_payments, err
}

const createPayment = `-- name: CreatePayment :one
INSERT INTO payments (user_id, order_id, amount, payment_method, status, updated_by, created_by)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id
`

type CreatePaymentParams struct {
	UserID        pgtype.Int8    `json:"user_id"`
	OrderID       int64          `json:"order_id"`
	Amount        pgtype.Numeric `json:"amount"`
	PaymentMethod string         `json:"payment_method"`
	Status        bool           `json:"status"`
	UpdatedBy     pgtype.Int8    `json:"updated_by"`
	CreatedBy     pgtype.Int8    `json:"created_by"`
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (int64, error) {
	row := q.db.QueryRow(ctx, createPayment,
		arg.UserID,
		arg.OrderID,
		arg.Amount,
		arg.PaymentMethod,
		arg.Status,
		arg.UpdatedBy,
		arg.CreatedBy,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getPayment = `-- name: GetPayment :one
SELECT id, order_id, user_id, payment_method, amount, status, updated_by, created_by, updated_at, created_at FROM payments
WHERE id = $1
`

func (q *Queries) GetPayment(ctx context.Context, id int64) (Payment, error) {
	row := q.db.QueryRow(ctx, getPayment, id)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.UserID,
		&i.PaymentMethod,
		&i.Amount,
		&i.Status,
		&i.UpdatedBy,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const listPayments = `-- name: ListPayments :many
SELECT 
    p.id, p.order_id, p.user_id, p.payment_method, p.amount, p.status, p.updated_by, p.created_by, p.updated_at, p.created_at,
    o.id AS order_id,
    o.status AS order_status,
    o.payment_status AS order_payment_status,
    u.id AS user_id,
    u.email AS user_email
FROM payments p
JOIN orders o ON p.order_id = o.id
LEFT JOIN users u ON p.user_id = u.id
WHERE
    (
        $1::bigint IS NULL 
        OR p.order_id = $1
    )
    AND (
        $2::bigint IS NULL 
        OR p.user_id = $2
    )
    AND (
        COALESCE($3, '') = '' 
        OR LOWER(p.payment_method) LIKE $3
    )
    AND (
        $4::boolean IS NULL 
        OR p.status = $4
    )
    AND (
        $5 IS NULL 
        OR p.created_at BETWEEN $5 AND $6
    )
ORDER BY p.created_at DESC
LIMIT $8 OFFSET $7
`

type ListPaymentsParams struct {
	OrderID       pgtype.Int8        `json:"order_id"`
	UserID        pgtype.Int8        `json:"user_id"`
	PaymentMethod interface{}        `json:"payment_method"`
	Status        pgtype.Bool        `json:"status"`
	StartDate     interface{}        `json:"start_date"`
	EndDate       pgtype.Timestamptz `json:"end_date"`
	Offset        int32              `json:"offset"`
	Limit         int32              `json:"limit"`
}

type ListPaymentsRow struct {
	ID                 int64          `json:"id"`
	OrderID            int64          `json:"order_id"`
	UserID             pgtype.Int8    `json:"user_id"`
	PaymentMethod      string         `json:"payment_method"`
	Amount             pgtype.Numeric `json:"amount"`
	Status             bool           `json:"status"`
	UpdatedBy          pgtype.Int8    `json:"updated_by"`
	CreatedBy          pgtype.Int8    `json:"created_by"`
	UpdatedAt          time.Time      `json:"updated_at"`
	CreatedAt          time.Time      `json:"created_at"`
	OrderID_2          int64          `json:"order_id_2"`
	OrderStatus        string         `json:"order_status"`
	OrderPaymentStatus bool           `json:"order_payment_status"`
	UserID_2           pgtype.Int8    `json:"user_id_2"`
	UserEmail          pgtype.Text    `json:"user_email"`
}

func (q *Queries) ListPayments(ctx context.Context, arg ListPaymentsParams) ([]ListPaymentsRow, error) {
	rows, err := q.db.Query(ctx, listPayments,
		arg.OrderID,
		arg.UserID,
		arg.PaymentMethod,
		arg.Status,
		arg.StartDate,
		arg.EndDate,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPaymentsRow{}
	for rows.Next() {
		var i ListPaymentsRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.UserID,
			&i.PaymentMethod,
			&i.Amount,
			&i.Status,
			&i.UpdatedBy,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.OrderID_2,
			&i.OrderStatus,
			&i.OrderPaymentStatus,
			&i.UserID_2,
			&i.UserEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePayment = `-- name: UpdatePayment :one
UPDATE payments
SET user_id = COALESCE($1, user_id),
    status = COALESCE($2, status),
    updated_by = $3,
    updated_at = NOW()
WHERE id = $4
RETURNING id, order_id, user_id, payment_method, amount, status, updated_by, created_by, updated_at, created_at
`

type UpdatePaymentParams struct {
	UserID    pgtype.Int8 `json:"user_id"`
	Status    bool        `json:"status"`
	UpdatedBy pgtype.Int8 `json:"updated_by"`
	ID        int64       `json:"id"`
}

func (q *Queries) UpdatePayment(ctx context.Context, arg UpdatePaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, updatePayment,
		arg.UserID,
		arg.Status,
		arg.UpdatedBy,
		arg.ID,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.UserID,
		&i.PaymentMethod,
		&i.Amount,
		&i.Status,
		&i.UpdatedBy,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
