// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: news_letters.sql

package generated

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countNewsLetters = `-- name: CountNewsLetters :one
SELECT COUNT(*) FROM news_letters
WHERE 
    deleted_at IS NULL
    AND (
        COALESCE($1::text, '') = ''
        OR LOWER(title) LIKE $1
        OR LOWER(description) LIKE $1
    )
    AND (
        $2::boolean IS NULL 
        OR published = $2
    )
    AND (
        $3::timestamptz IS NULL 
        OR date >= $3
    )
    AND (
        $4::timestamptz IS NULL 
        OR date <= $4
    )
`

type CountNewsLettersParams struct {
	Search    pgtype.Text        `json:"search"`
	Published pgtype.Bool        `json:"published"`
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

func (q *Queries) CountNewsLetters(ctx context.Context, arg CountNewsLettersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countNewsLetters,
		arg.Search,
		arg.Published,
		arg.StartDate,
		arg.EndDate,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createNewsLetter = `-- name: CreateNewsLetter :one
INSERT INTO news_letters (title, description, storage_path, pdf_url, date, updated_by, created_by)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id
`

type CreateNewsLetterParams struct {
	Title       string    `json:"title"`
	Description string    `json:"description"`
	StoragePath string    `json:"storage_path"`
	PdfUrl      string    `json:"pdf_url"`
	Date        time.Time `json:"date"`
	UpdatedBy   int64     `json:"updated_by"`
	CreatedBy   int64     `json:"created_by"`
}

func (q *Queries) CreateNewsLetter(ctx context.Context, arg CreateNewsLetterParams) (int64, error) {
	row := q.db.QueryRow(ctx, createNewsLetter,
		arg.Title,
		arg.Description,
		arg.StoragePath,
		arg.PdfUrl,
		arg.Date,
		arg.UpdatedBy,
		arg.CreatedBy,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteNewsLetter = `-- name: DeleteNewsLetter :exec
UPDATE news_letters
SET deleted_at = NOW(),
    deleted_by = $1
WHERE id = $2
`

type DeleteNewsLetterParams struct {
	DeletedBy pgtype.Int8 `json:"deleted_by"`
	ID        int64       `json:"id"`
}

func (q *Queries) DeleteNewsLetter(ctx context.Context, arg DeleteNewsLetterParams) error {
	_, err := q.db.Exec(ctx, deleteNewsLetter, arg.DeletedBy, arg.ID)
	return err
}

const getNewsLetter = `-- name: GetNewsLetter :one
SELECT id, title, description, storage_path, pdf_url, date, published, published_at, updated_by, created_by, deleted_by, deleted_at, updated_at, created_at FROM news_letters
WHERE id = $1
`

func (q *Queries) GetNewsLetter(ctx context.Context, id int64) (NewsLetter, error) {
	row := q.db.QueryRow(ctx, getNewsLetter, id)
	var i NewsLetter
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.StoragePath,
		&i.PdfUrl,
		&i.Date,
		&i.Published,
		&i.PublishedAt,
		&i.UpdatedBy,
		&i.CreatedBy,
		&i.DeletedBy,
		&i.DeletedAt,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getPublishedNewsLetter = `-- name: GetPublishedNewsLetter :one
SELECT id, title, description, storage_path, pdf_url, date, published, published_at, updated_by, created_by, deleted_by, deleted_at, updated_at, created_at FROM news_letters
WHERE id = $1 AND published = TRUE AND deleted_at IS NULL
`

func (q *Queries) GetPublishedNewsLetter(ctx context.Context, id int64) (NewsLetter, error) {
	row := q.db.QueryRow(ctx, getPublishedNewsLetter, id)
	var i NewsLetter
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.StoragePath,
		&i.PdfUrl,
		&i.Date,
		&i.Published,
		&i.PublishedAt,
		&i.UpdatedBy,
		&i.CreatedBy,
		&i.DeletedBy,
		&i.DeletedAt,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const listNewsLetters = `-- name: ListNewsLetters :many
SELECT id, title, description, storage_path, pdf_url, date, published, published_at, updated_by, created_by, deleted_by, deleted_at, updated_at, created_at FROM news_letters
WHERE 
    deleted_at IS NULL
    AND (
        COALESCE($1::text, '') = ''
        OR LOWER(title) LIKE $1
        OR LOWER(description) LIKE $1
    )
    AND (
        $2::boolean IS NULL 
        OR published = $2
    )
    AND (
        $3::timestamptz IS NULL 
        OR date >= $3
    )
    AND (
        $4::timestamptz IS NULL 
        OR date <= $4
    )
ORDER BY created_at DESC
LIMIT $6 OFFSET $5
`

type ListNewsLettersParams struct {
	Search    pgtype.Text        `json:"search"`
	Published pgtype.Bool        `json:"published"`
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
	Offset    int32              `json:"offset"`
	Limit     int32              `json:"limit"`
}

func (q *Queries) ListNewsLetters(ctx context.Context, arg ListNewsLettersParams) ([]NewsLetter, error) {
	rows, err := q.db.Query(ctx, listNewsLetters,
		arg.Search,
		arg.Published,
		arg.StartDate,
		arg.EndDate,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NewsLetter{}
	for rows.Next() {
		var i NewsLetter
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.StoragePath,
			&i.PdfUrl,
			&i.Date,
			&i.Published,
			&i.PublishedAt,
			&i.UpdatedBy,
			&i.CreatedBy,
			&i.DeletedBy,
			&i.DeletedAt,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const publishNewsLetter = `-- name: PublishNewsLetter :one
UPDATE news_letters
SET published = TRUE,
    published_at = NOW(),
    updated_by = $1,
    updated_at = NOW()
WHERE id = $2
RETURNING id, title, description, storage_path, pdf_url, date, published, published_at, updated_by, created_by, deleted_by, deleted_at, updated_at, created_at
`

type PublishNewsLetterParams struct {
	UpdatedBy int64 `json:"updated_by"`
	ID        int64 `json:"id"`
}

func (q *Queries) PublishNewsLetter(ctx context.Context, arg PublishNewsLetterParams) (NewsLetter, error) {
	row := q.db.QueryRow(ctx, publishNewsLetter, arg.UpdatedBy, arg.ID)
	var i NewsLetter
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.StoragePath,
		&i.PdfUrl,
		&i.Date,
		&i.Published,
		&i.PublishedAt,
		&i.UpdatedBy,
		&i.CreatedBy,
		&i.DeletedBy,
		&i.DeletedAt,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateNewsLetter = `-- name: UpdateNewsLetter :exec
UPDATE news_letters
SET title = COALESCE($1, title),
    description = COALESCE($2, description),
    storage_path = COALESCE($3, storage_path),
    pdf_url = COALESCE($4, pdf_url),
    date = COALESCE($5, date),
    updated_by = $6,
    updated_at = NOW()
WHERE id = $7
`

type UpdateNewsLetterParams struct {
	Title       pgtype.Text        `json:"title"`
	Description pgtype.Text        `json:"description"`
	StoragePath pgtype.Text        `json:"storage_path"`
	PdfUrl      pgtype.Text        `json:"pdf_url"`
	Date        pgtype.Timestamptz `json:"date"`
	UpdatedBy   int64              `json:"updated_by"`
	ID          int64              `json:"id"`
}

func (q *Queries) UpdateNewsLetter(ctx context.Context, arg UpdateNewsLetterParams) error {
	_, err := q.db.Exec(ctx, updateNewsLetter,
		arg.Title,
		arg.Description,
		arg.StoragePath,
		arg.PdfUrl,
		arg.Date,
		arg.UpdatedBy,
		arg.ID,
	)
	return err
}

const updateNewsLetterPdfUrl = `-- name: UpdateNewsLetterPdfUrl :exec
UPDATE news_letters
SET pdf_url = $2
WHERE id = $1
`

type UpdateNewsLetterPdfUrlParams struct {
	ID     int64  `json:"id"`
	PdfUrl string `json:"pdf_url"`
}

func (q *Queries) UpdateNewsLetterPdfUrl(ctx context.Context, arg UpdateNewsLetterPdfUrlParams) error {
	_, err := q.db.Exec(ctx, updateNewsLetterPdfUrl, arg.ID, arg.PdfUrl)
	return err
}
