// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: orders.sql

package generated

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countOrders = `-- name: CountOrders :one
SELECT COUNT(*) AS total_orders
FROM orders
WHERE 
    (
        $1::boolean IS NULL 
        OR payment_status = $1
    )
    AND (
        $2::text IS NULL 
        OR status = $2
    )
    AND (
        $3::bigint IS NULL 
        OR user_id = $3
    )
`

type CountOrdersParams struct {
	PaymentStatus pgtype.Bool `json:"payment_status"`
	Status        pgtype.Text `json:"status"`
	UserID        pgtype.Int8 `json:"user_id"`
}

func (q *Queries) CountOrders(ctx context.Context, arg CountOrdersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOrders, arg.PaymentStatus, arg.Status, arg.UserID)
	var total_orders int64
	err := row.Scan(&total_orders)
	return total_orders, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (user_id, amount, status, payment_status, order_details)
VALUES ($1, $2, $3, $4, $5)
RETURNING id
`

type CreateOrderParams struct {
	UserID        pgtype.Int8    `json:"user_id"`
	Amount        pgtype.Numeric `json:"amount"`
	Status        string         `json:"status"`
	PaymentStatus bool           `json:"payment_status"`
	OrderDetails  []byte         `json:"order_details"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (int64, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.UserID,
		arg.Amount,
		arg.Status,
		arg.PaymentStatus,
		arg.OrderDetails,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getOrder = `-- name: GetOrder :one
SELECT 
    o.id, o.user_id, o.amount, o.status, o.payment_status, o.order_details, o.updated_by, o.updated_at, o.created_at,
    COALESCE(p1.order_items_json, '[]') as order_items,
    COALESCE(p2.user_json, '{}') as user
FROM orders o
LEFT JOIN LATERAL (
    SELECT json_agg(json_build_object(
        'product_id', oi.product_id,
        'size', oi.size,
        'color', oi.color,
        'quantity', oi.quantity,
        'amount', oi.amount,
        'product', json_build_object(
            'id', p.id,
            'name', p.name,
            'price', p.price,
            'image_url', p.image_url
        )
    )) AS order_items_json
    FROM order_items oi
    JOIN products p ON oi.product_id = p.id
    WHERE oi.order_id = o.id
) p1 ON true
LEFT JOIN LATERAL (
    SELECT json_build_object(
        'id', u.id,
        'email', u.email,
        'full_name', u.full_name,
        'role', u.role
    ) AS user_json
    FROM users u
    WHERE u.id = o.user_id
) p2 ON true
WHERE o.id = $1
`

type GetOrderRow struct {
	ID            int64          `json:"id"`
	UserID        pgtype.Int8    `json:"user_id"`
	Amount        pgtype.Numeric `json:"amount"`
	Status        string         `json:"status"`
	PaymentStatus bool           `json:"payment_status"`
	OrderDetails  []byte         `json:"order_details"`
	UpdatedBy     pgtype.Int8    `json:"updated_by"`
	UpdatedAt     time.Time      `json:"updated_at"`
	CreatedAt     time.Time      `json:"created_at"`
	OrderItems    []byte         `json:"order_items"`
	User          []byte         `json:"user"`
}

func (q *Queries) GetOrder(ctx context.Context, id int64) (GetOrderRow, error) {
	row := q.db.QueryRow(ctx, getOrder, id)
	var i GetOrderRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Amount,
		&i.Status,
		&i.PaymentStatus,
		&i.OrderDetails,
		&i.UpdatedBy,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.OrderItems,
		&i.User,
	)
	return i, err
}

const listOrders = `-- name: ListOrders :many
SELECT id, user_id, amount, status, payment_status, order_details, updated_by, updated_at, created_at FROM orders
WHERE 
    (
        $1::boolean IS NULL 
        OR payment_status = $1
    )
    AND (
        $2::text IS NULL 
        OR status = $2
    )
    AND (
        $3::bigint IS NULL 
        OR user_id = $3
    )
ORDER BY created_at DESC
LIMIT $5 OFFSET $4
`

type ListOrdersParams struct {
	PaymentStatus pgtype.Bool `json:"payment_status"`
	Status        pgtype.Text `json:"status"`
	UserID        pgtype.Int8 `json:"user_id"`
	Offset        int32       `json:"offset"`
	Limit         int32       `json:"limit"`
}

func (q *Queries) ListOrders(ctx context.Context, arg ListOrdersParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listOrders,
		arg.PaymentStatus,
		arg.Status,
		arg.UserID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Amount,
			&i.Status,
			&i.PaymentStatus,
			&i.OrderDetails,
			&i.UpdatedBy,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrder = `-- name: UpdateOrder :one
UPDATE orders
SET user_id = COALESCE($1, user_id),
    status = COALESCE($2, status),
    payment_status = COALESCE($3, payment_status),
    updated_by = $4,
    updated_at = NOW()
WHERE id = $5
RETURNING id, user_id, amount, status, payment_status, order_details, updated_by, updated_at, created_at
`

type UpdateOrderParams struct {
	UserID        pgtype.Int8 `json:"user_id"`
	Status        pgtype.Text `json:"status"`
	PaymentStatus pgtype.Bool `json:"payment_status"`
	UpdatedBy     pgtype.Int8 `json:"updated_by"`
	ID            int64       `json:"id"`
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrder,
		arg.UserID,
		arg.Status,
		arg.PaymentStatus,
		arg.UpdatedBy,
		arg.ID,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Amount,
		&i.Status,
		&i.PaymentStatus,
		&i.OrderDetails,
		&i.UpdatedBy,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
